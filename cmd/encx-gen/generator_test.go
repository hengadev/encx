package main

import (
	"os"
	"path/filepath"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestNewGenerator(t *testing.T) {
	tempDir := t.TempDir()
	configPath := filepath.Join(tempDir, "encx.yaml")

	// Create a simple config file
	err := os.WriteFile(configPath, []byte(`
generation:
  output_suffix: "_encx"
  function_prefix: "Process"
  package_name: "encx"
  default_serializer: "json"
`), 0644)
	require.NoError(t, err)

	generator := NewGenerator(configPath, tempDir, true)

	assert.NotNil(t, generator)
	assert.Equal(t, tempDir, generator.outputDir)
	assert.True(t, generator.verbose)
	assert.NotNil(t, generator.config)
	assert.NotNil(t, generator.cache)
}

func TestNewGeneratorWithInvalidConfig(t *testing.T) {
	tempDir := t.TempDir()
	invalidConfigPath := "/nonexistent/config.yaml"

	generator := NewGenerator(invalidConfigPath, tempDir, false)

	// Should create generator with default config
	assert.NotNil(t, generator)
	assert.Equal(t, tempDir, generator.outputDir)
	assert.False(t, generator.verbose)
	assert.NotNil(t, generator.config)
}

func TestGenerateDryRun(t *testing.T) {
	tempDir := t.TempDir()

	// Create test source file
	sourceFile := filepath.Join(tempDir, "user.go")
	err := os.WriteFile(sourceFile, []byte(`package test

type User struct {
	Email string `+"`json:\"email\" encx:\"encrypt\"`"+`
	EmailEncrypted []byte `+"`json:\"email_encrypted\"`"+`
}
`), 0644)
	require.NoError(t, err)

	generator := NewGenerator("", tempDir, true)

	err = generator.Generate([]string{tempDir}, true)
	require.NoError(t, err)

	// Verify no files were generated (dry run)
	expectedOutput := filepath.Join(tempDir, "user_encx.go")
	_, err = os.Stat(expectedOutput)
	assert.True(t, os.IsNotExist(err), "File should not exist in dry run")
}

func TestGenerateActualGeneration(t *testing.T) {
	tempDir := t.TempDir()

	// Create test source file
	sourceFile := filepath.Join(tempDir, "user.go")
	err := os.WriteFile(sourceFile, []byte(`package test

type User struct {
	Email string `+"`json:\"email\" encx:\"encrypt\"`"+`
	EmailEncrypted []byte `+"`json:\"email_encrypted\"`"+`
}
`), 0644)
	require.NoError(t, err)

	generator := NewGenerator("", tempDir, false)

	err = generator.Generate([]string{tempDir}, false)
	require.NoError(t, err)

	// Verify file was generated
	expectedOutput := filepath.Join(tempDir, "user_encx.go")
	_, err = os.Stat(expectedOutput)
	assert.NoError(t, err, "Generated file should exist")

	// Verify cache was created
	cacheFile := filepath.Join(tempDir, ".encx-gen-cache.json")
	_, err = os.Stat(cacheFile)
	assert.NoError(t, err, "Cache file should exist")

	// Read and verify generated content
	content, err := os.ReadFile(expectedOutput)
	require.NoError(t, err)

	contentStr := string(content)
	assert.Contains(t, contentStr, "Code generated by encx-gen. DO NOT EDIT.")
	assert.Contains(t, contentStr, "type UserEncx struct")
	assert.Contains(t, contentStr, "func ProcessUserEncx")
	assert.Contains(t, contentStr, "func DecryptUserEncx")
}

func TestGenerateWithValidationErrors(t *testing.T) {
	tempDir := t.TempDir()

	// Create test source file with validation errors
	sourceFile := filepath.Join(tempDir, "invalid.go")
	err := os.WriteFile(sourceFile, []byte(`package test

type InvalidUser struct {
	// Invalid: both hash types
	Email string `+"`json:\"email\" encx:\"hash_basic,hash_secure\"`"+`

	// Missing companion field
	Phone string `+"`json:\"phone\" encx:\"encrypt\"`"+`
}
`), 0644)
	require.NoError(t, err)

	generator := NewGenerator("", tempDir, true)

	err = generator.Generate([]string{tempDir}, false)
	require.NoError(t, err) // Should not fail, but should skip invalid structs

	// Verify no file was generated due to validation errors
	expectedOutput := filepath.Join(tempDir, "invalid_encx.go")
	_, err = os.Stat(expectedOutput)
	assert.True(t, os.IsNotExist(err), "File should not be generated for invalid struct")
}

func TestCacheOperations(t *testing.T) {
	tempDir := t.TempDir()
	cacheFile := filepath.Join(tempDir, ".encx-gen-cache.json")

	generator := NewGenerator("", tempDir, false)

	// Test initial cache state
	err := generator.loadCache()
	require.NoError(t, err)
	assert.NotNil(t, generator.cache)
	assert.Empty(t, generator.cache.SourceHashes)
	assert.Empty(t, generator.cache.GeneratedFiles)

	// Add some data to cache
	generator.cache.SourceHashes["test.go"] = "abcd1234"
	generator.cache.GeneratedFiles["test_encx.go"] = GeneratedFileInfo{
		SourceFile:    "test.go",
		SourceHash:    "abcd1234",
		GeneratedTime: time.Now(),
	}
	generator.cache.LastGenerated = time.Now()

	// Save cache
	err = generator.saveCache()
	require.NoError(t, err)

	// Verify cache file exists
	_, err = os.Stat(cacheFile)
	assert.NoError(t, err)

	// Load cache in new generator instance
	newGenerator := NewGenerator("", tempDir, false)
	err = newGenerator.loadCache()
	require.NoError(t, err)

	assert.Len(t, newGenerator.cache.SourceHashes, 1)
	assert.Equal(t, "abcd1234", newGenerator.cache.SourceHashes["test.go"])
	assert.Len(t, newGenerator.cache.GeneratedFiles, 1)
}

func TestCalculateFileHash(t *testing.T) {
	tempDir := t.TempDir()
	testFile := filepath.Join(tempDir, "test.go")

	content := []byte("package test\n\ntype Test struct {}")
	err := os.WriteFile(testFile, content, 0644)
	require.NoError(t, err)

	generator := NewGenerator("", tempDir, false)

	hash1, err := generator.calculateFileHash(testFile)
	require.NoError(t, err)
	assert.NotEmpty(t, hash1)

	// Calculate hash again - should be same
	hash2, err := generator.calculateFileHash(testFile)
	require.NoError(t, err)
	assert.Equal(t, hash1, hash2)

	// Modify file
	modifiedContent := append(content, []byte("\n// comment")...)
	err = os.WriteFile(testFile, modifiedContent, 0644)
	require.NoError(t, err)

	hash3, err := generator.calculateFileHash(testFile)
	require.NoError(t, err)
	assert.NotEqual(t, hash1, hash3, "Hash should change when file content changes")
}

func TestNeedsRegeneration(t *testing.T) {
	tempDir := t.TempDir()

	sourceFile := filepath.Join(tempDir, "user.go")
	outputFile := filepath.Join(tempDir, "user_encx.go")

	// Create source file
	err := os.WriteFile(sourceFile, []byte("package test\ntype User struct {}"), 0644)
	require.NoError(t, err)

	generator := NewGenerator("", tempDir, false)

	// First check - should need regeneration (no cache)
	needs, err := generator.needsRegeneration(sourceFile, outputFile)
	require.NoError(t, err)
	assert.True(t, needs, "Should need regeneration when no cache exists")

	// Create output file and update cache
	err = os.WriteFile(outputFile, []byte("// generated code"), 0644)
	require.NoError(t, err)

	err = generator.updateCache(sourceFile, outputFile)
	require.NoError(t, err)

	// Second check - should not need regeneration
	needs, err = generator.needsRegeneration(sourceFile, outputFile)
	require.NoError(t, err)
	assert.False(t, needs, "Should not need regeneration when file is up to date")

	// Modify source file
	time.Sleep(10 * time.Millisecond) // Ensure different timestamp
	err = os.WriteFile(sourceFile, []byte("package test\ntype User struct { Name string }"), 0644)
	require.NoError(t, err)

	// Third check - should need regeneration (source changed)
	needs, err = generator.needsRegeneration(sourceFile, outputFile)
	require.NoError(t, err)
	assert.True(t, needs, "Should need regeneration when source file changes")
}

func TestUpdateCache(t *testing.T) {
	tempDir := t.TempDir()

	sourceFile := filepath.Join(tempDir, "user.go")
	outputFile := filepath.Join(tempDir, "user_encx.go")

	// Create source file
	content := []byte("package test\ntype User struct {}")
	err := os.WriteFile(sourceFile, content, 0644)
	require.NoError(t, err)

	generator := NewGenerator("", tempDir, false)

	err = generator.updateCache(sourceFile, outputFile)
	require.NoError(t, err)

	// Verify cache was updated
	assert.Contains(t, generator.cache.SourceHashes, sourceFile)
	assert.Contains(t, generator.cache.GeneratedFiles, outputFile)

	genInfo := generator.cache.GeneratedFiles[outputFile]
	assert.Equal(t, sourceFile, genInfo.SourceFile)
	assert.Equal(t, generator.cache.SourceHashes[sourceFile], genInfo.SourceHash)
	assert.False(t, genInfo.GeneratedTime.IsZero())
}

func TestGenerateWithSkippedPackages(t *testing.T) {
	tempDir := t.TempDir()
	configFile := filepath.Join(tempDir, "encx.yaml")

	// Create config that skips a package
	configContent := `
generation:
  output_suffix: "_encx"
packages:
  ./skip_me:
    skip: true
`
	err := os.WriteFile(configFile, []byte(configContent), 0644)
	require.NoError(t, err)

	// Create source file in skipped package directory
	skipDir := filepath.Join(tempDir, "skip_me")
	err = os.MkdirAll(skipDir, 0755)
	require.NoError(t, err)

	sourceFile := filepath.Join(skipDir, "user.go")
	err = os.WriteFile(sourceFile, []byte(`package skip_me

type User struct {
	Email string `+"`json:\"email\" encx:\"encrypt\"`"+`
	EmailEncrypted []byte `+"`json:\"email_encrypted\"`"+`
}
`), 0644)
	require.NoError(t, err)

	generator := NewGenerator(configFile, tempDir, true)

	err = generator.Generate([]string{skipDir}, false)
	require.NoError(t, err)

	// Verify no file was generated (package was skipped)
	expectedOutput := filepath.Join(skipDir, "user_encx.go")
	_, err = os.Stat(expectedOutput)
	assert.True(t, os.IsNotExist(err), "File should not be generated for skipped package")
}

func TestIncrementalGeneration(t *testing.T) {
	tempDir := t.TempDir()

	// Create source file
	sourceFile := filepath.Join(tempDir, "user.go")
	err := os.WriteFile(sourceFile, []byte(`package test

type User struct {
	Email string `+"`json:\"email\" encx:\"encrypt\"`"+`
	EmailEncrypted []byte `+"`json:\"email_encrypted\"`"+`
}
`), 0644)
	require.NoError(t, err)

	generator := NewGenerator("", tempDir, false)

	// First generation
	err = generator.Generate([]string{tempDir}, false)
	require.NoError(t, err)

	expectedOutput := filepath.Join(tempDir, "user_encx.go")
	info1, err := os.Stat(expectedOutput)
	require.NoError(t, err)

	// Second generation without changes - should skip
	time.Sleep(10 * time.Millisecond)
	err = generator.Generate([]string{tempDir}, false)
	require.NoError(t, err)

	info2, err := os.Stat(expectedOutput)
	require.NoError(t, err)

	// File should not have been modified (incremental generation working)
	assert.Equal(t, info1.ModTime(), info2.ModTime(), "File should not be regenerated when source unchanged")

	// Modify source file
	time.Sleep(10 * time.Millisecond)
	err = os.WriteFile(sourceFile, []byte(`package test

// Added comment
type User struct {
	Email string `+"`json:\"email\" encx:\"encrypt\"`"+`
	EmailEncrypted []byte `+"`json:\"email_encrypted\"`"+`
}
`), 0644)
	require.NoError(t, err)

	// Third generation with changes - should regenerate
	err = generator.Generate([]string{tempDir}, false)
	require.NoError(t, err)

	info3, err := os.Stat(expectedOutput)
	require.NoError(t, err)

	// File should have been modified (regeneration triggered by source change)
	assert.True(t, info3.ModTime().After(info2.ModTime()), "File should be regenerated when source changes")
}