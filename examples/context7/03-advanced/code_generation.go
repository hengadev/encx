// Package advanced demonstrates high-performance code generation with encx
//
// Context7 Tags: code-generation, performance-optimization, type-safety, production-ready
// Complexity: Advanced
// Use Case: High-performance encryption with compile-time type safety

package main

import (
	"context"
	"fmt"
	"log"
	"time"

	"github.com/hengadev/encx"
)

//go:generate encx-gen validate -v .
//go:generate encx-gen generate -v .

// User demonstrates the code generation approach
// Notice: NO companion fields needed - they're generated automatically
type User struct {
	// Basic information
	ID        int       `json:"id" db:"id"`
	CreatedAt time.Time `json:"created_at" db:"created_at"`
	UpdatedAt time.Time `json:"updated_at" db:"updated_at"`

	// Searchable encrypted fields
	Email     string `json:"email" encx:"encrypt,hash_basic" db:"email"`
	Phone     string `json:"phone" encx:"encrypt,hash_basic" db:"phone"`

	// Personal information (encrypted only)
	FirstName string `json:"first_name" encx:"encrypt" db:"first_name"`
	LastName  string `json:"last_name" encx:"encrypt" db:"last_name"`
	Address   string `json:"address" encx:"encrypt" db:"address"`

	// Secure data (hashed only - no decryption needed)
	SSN string `json:"ssn" encx:"hash_secure" db:"ssn"`

	// No companion fields needed! Generated automatically in UserEncx struct
}

// Product demonstrates different encryption patterns
type Product struct {
	ID          int     `json:"id" db:"id"`
	PublicName  string  `json:"name" db:"name"`  // Not encrypted
	Price       float64 `json:"price" db:"price"` // Not encrypted

	// Encrypted fields
	InternalNotes string `json:"internal_notes" encx:"encrypt" db:"internal_notes"`
	SupplierInfo  string `json:"supplier_info" encx:"encrypt" db:"supplier_info"`

	// Searchable product code
	ProductCode string `json:"product_code" encx:"hash_basic" db:"product_code"`
}

// Simulated generated structs (would be generated by encx-gen)
type UserEncx struct {
	// Basic information (not encrypted)
	ID        int       `json:"id"`
	CreatedAt time.Time `json:"created_at"`
	UpdatedAt time.Time `json:"updated_at"`

	// Encrypted and hashed fields
	EmailEncrypted []byte `json:"email_encrypted"`
	EmailHash      string `json:"email_hash"`
	PhoneEncrypted []byte `json:"phone_encrypted"`
	PhoneHash      string `json:"phone_hash"`
	FirstNameEncrypted []byte `json:"first_name_encrypted"`
	LastNameEncrypted  []byte `json:"last_name_encrypted"`
	AddressEncrypted   []byte `json:"address_encrypted"`

	// Secure hash (no encryption)
	SSNHashSecure string `json:"ssn_hash_secure"`

	// Encryption metadata
	DEKEncrypted []byte `json:"dek_encrypted"`
	KeyVersion   int    `json:"key_version"`
	Metadata     string `json:"metadata,omitempty"`
}

type ProductEncx struct {
	// Public fields (not encrypted)
	ID         int     `json:"id"`
	PublicName string  `json:"name"`
	Price      float64 `json:"price"`

	// Encrypted fields
	InternalNotesEncrypted []byte `json:"internal_notes_encrypted"`
	SupplierInfoEncrypted  []byte `json:"supplier_info_encrypted"`

	// Hashed field
	ProductCodeHash string `json:"product_code_hash"`

	// Encryption metadata
	DEKEncrypted []byte `json:"dek_encrypted"`
	KeyVersion   int    `json:"key_version"`
	Metadata     string `json:"metadata,omitempty"`
}

// Simulation functions (represent what generated code would do)

func simulateUserEncryption(ctx context.Context, crypto *encx.Crypto, user *User) (*UserEncx, error) {
	// Generate a DEK for this user
	dek, err := crypto.GenerateDEK()
	if err != nil {
		return nil, fmt.Errorf("failed to generate DEK: %w", err)
	}

	userEncx := &UserEncx{
		ID:        user.ID,
		CreatedAt: user.CreatedAt,
		UpdatedAt: user.UpdatedAt,
	}

	// Encrypt and hash email
	if user.Email != "" {
		emailBytes := []byte(user.Email)
		userEncx.EmailEncrypted, err = crypto.EncryptData(ctx, emailBytes, dek)
		if err != nil {
			return nil, fmt.Errorf("failed to encrypt email: %w", err)
		}
		userEncx.EmailHash = crypto.HashBasic(ctx, emailBytes)
	}

	// Encrypt and hash phone
	if user.Phone != "" {
		phoneBytes := []byte(user.Phone)
		userEncx.PhoneEncrypted, err = crypto.EncryptData(ctx, phoneBytes, dek)
		if err != nil {
			return nil, fmt.Errorf("failed to encrypt phone: %w", err)
		}
		userEncx.PhoneHash = crypto.HashBasic(ctx, phoneBytes)
	}

	// Encrypt personal information
	if user.FirstName != "" {
		fnBytes := []byte(user.FirstName)
		userEncx.FirstNameEncrypted, err = crypto.EncryptData(ctx, fnBytes, dek)
		if err != nil {
			return nil, fmt.Errorf("failed to encrypt first name: %w", err)
		}
	}

	if user.LastName != "" {
		lnBytes := []byte(user.LastName)
		userEncx.LastNameEncrypted, err = crypto.EncryptData(ctx, lnBytes, dek)
		if err != nil {
			return nil, fmt.Errorf("failed to encrypt last name: %w", err)
		}
	}

	if user.Address != "" {
		addrBytes := []byte(user.Address)
		userEncx.AddressEncrypted, err = crypto.EncryptData(ctx, addrBytes, dek)
		if err != nil {
			return nil, fmt.Errorf("failed to encrypt address: %w", err)
		}
	}

	// Hash secure data
	if user.SSN != "" {
		userEncx.SSNHashSecure, err = crypto.HashSecure(ctx, []byte(user.SSN))
		if err != nil {
			return nil, fmt.Errorf("failed to hash SSN: %w", err)
		}
	}

	// Encrypt and store DEK
	userEncx.DEKEncrypted, err = crypto.EncryptDEK(ctx, dek)
	if err != nil {
		return nil, fmt.Errorf("failed to encrypt DEK: %w", err)
	}
	userEncx.KeyVersion = 1

	return userEncx, nil
}

func simulateUserDecryption(ctx context.Context, crypto *encx.Crypto, userEncx *UserEncx) (*User, error) {
	// Decrypt the DEK
	dek, err := crypto.DecryptDEKWithVersion(ctx, userEncx.DEKEncrypted, userEncx.KeyVersion)
	if err != nil {
		return nil, fmt.Errorf("failed to decrypt DEK: %w", err)
	}

	user := &User{
		ID:        userEncx.ID,
		CreatedAt: userEncx.CreatedAt,
		UpdatedAt: userEncx.UpdatedAt,
	}

	// Decrypt encrypted fields
	if len(userEncx.EmailEncrypted) > 0 {
		emailBytes, err := crypto.DecryptData(ctx, userEncx.EmailEncrypted, dek)
		if err != nil {
			return nil, fmt.Errorf("failed to decrypt email: %w", err)
		}
		user.Email = string(emailBytes)
	}

	if len(userEncx.PhoneEncrypted) > 0 {
		phoneBytes, err := crypto.DecryptData(ctx, userEncx.PhoneEncrypted, dek)
		if err != nil {
			return nil, fmt.Errorf("failed to decrypt phone: %w", err)
		}
		user.Phone = string(phoneBytes)
	}

	if len(userEncx.FirstNameEncrypted) > 0 {
		fnBytes, err := crypto.DecryptData(ctx, userEncx.FirstNameEncrypted, dek)
		if err != nil {
			return nil, fmt.Errorf("failed to decrypt first name: %w", err)
		}
		user.FirstName = string(fnBytes)
	}

	if len(userEncx.LastNameEncrypted) > 0 {
		lnBytes, err := crypto.DecryptData(ctx, userEncx.LastNameEncrypted, dek)
		if err != nil {
			return nil, fmt.Errorf("failed to decrypt last name: %w", err)
		}
		user.LastName = string(lnBytes)
	}

	if len(userEncx.AddressEncrypted) > 0 {
		addrBytes, err := crypto.DecryptData(ctx, userEncx.AddressEncrypted, dek)
		if err != nil {
			return nil, fmt.Errorf("failed to decrypt address: %w", err)
		}
		user.Address = string(addrBytes)
	}

	// Note: SSN is hashed only and cannot be decrypted

	return user, nil
}

func simulateProductEncryption(ctx context.Context, crypto *encx.Crypto, product *Product) (*ProductEncx, error) {
	// Generate a DEK for this product
	dek, err := crypto.GenerateDEK()
	if err != nil {
		return nil, fmt.Errorf("failed to generate DEK: %w", err)
	}

	productEncx := &ProductEncx{
		ID:         product.ID,
		PublicName: product.PublicName,
		Price:      product.Price,
	}

	// Encrypt internal notes
	if product.InternalNotes != "" {
		notesBytes := []byte(product.InternalNotes)
		productEncx.InternalNotesEncrypted, err = crypto.EncryptData(ctx, notesBytes, dek)
		if err != nil {
			return nil, fmt.Errorf("failed to encrypt internal notes: %w", err)
		}
	}

	// Encrypt supplier info
	if product.SupplierInfo != "" {
		supplierBytes := []byte(product.SupplierInfo)
		productEncx.SupplierInfoEncrypted, err = crypto.EncryptData(ctx, supplierBytes, dek)
		if err != nil {
			return nil, fmt.Errorf("failed to encrypt supplier info: %w", err)
		}
	}

	// Hash product code
	if product.ProductCode != "" {
		productEncx.ProductCodeHash = crypto.HashBasic(ctx, []byte(product.ProductCode))
	}

	// Encrypt and store DEK
	productEncx.DEKEncrypted, err = crypto.EncryptDEK(ctx, dek)
	if err != nil {
		return nil, fmt.Errorf("failed to encrypt DEK: %w", err)
	}
	productEncx.KeyVersion = 1

	return productEncx, nil
}


func main() {
	ctx := context.Background()
	crypto, err := encx.NewTestCrypto(nil)
	if err != nil {
		log.Fatal("Failed to create crypto service:", err)
	}

	// Example 1: Using generated functions for User
	fmt.Println("=== Code Generation Example: User Processing ===")

	user := &User{
		ID:        1,
		CreatedAt: time.Now(),
		UpdatedAt: time.Now(),
		Email:     "john.doe@example.com",
		Phone:     "+1-555-123-4567",
		FirstName: "John",
		LastName:  "Doe",
		Address:   "123 Main St, Springfield, IL",
		SSN:       "123-45-6789",
	}

	fmt.Printf("Original user: %+v\n", user)

	// Note: Generated functions would be available after running encx-gen
	// For this demo, we'll simulate the manual encryption process
	userEncx, err := simulateUserEncryption(ctx, crypto, user)
	if err != nil {
		log.Fatal("Failed to process user with manual encryption:", err)
	}

	fmt.Printf("Generated UserEncx struct has encrypted data:\n")
	fmt.Printf("  EmailEncrypted: %d bytes\n", len(userEncx.EmailEncrypted))
	fmt.Printf("  EmailHash: %s...\n", userEncx.EmailHash[:16])
	fmt.Printf("  FirstNameEncrypted: %d bytes\n", len(userEncx.FirstNameEncrypted))
	fmt.Printf("  SSNHashSecure: %s...\n", userEncx.SSNHashSecure[:20])

	// Decrypt using simulated function
	decryptedUser, err := simulateUserDecryption(ctx, crypto, userEncx)
	if err != nil {
		log.Fatal("Failed to decrypt user:", err)
	}

	fmt.Printf("Decrypted user: %+v\n", decryptedUser)

	fmt.Println()

	// Example 2: Product processing
	fmt.Println("=== Code Generation Example: Product Processing ===")

	product := &Product{
		ID:            100,
		PublicName:    "Widget Pro",
		Price:         29.99,
		InternalNotes: "High margin item, promote heavily",
		SupplierInfo:  "Acme Corp - contact: supplier@acme.com",
		ProductCode:   "WIDGET-PRO-2024",
	}

	// Use simulated functions (generated functions would be available after encx-gen)
	productEncx, err := simulateProductEncryption(ctx, crypto, product)
	if err != nil {
		log.Fatal("Failed to process product:", err)
	}

	fmt.Printf("Product encrypted successfully\n")
	fmt.Printf("  Public fields remain: Name=%s, Price=%.2f\n",
		productEncx.PublicName, productEncx.Price)
	fmt.Printf("  InternalNotesEncrypted: %d bytes\n", len(productEncx.InternalNotesEncrypted))
	fmt.Printf("  ProductCodeHash: %s...\n", productEncx.ProductCodeHash[:16])
}

// Production patterns using code generation

// Pattern 1: Service layer with generated functions
type UserService struct {
	crypto *encx.Crypto
}

func NewUserService(crypto *encx.Crypto) *UserService {
	return &UserService{crypto: crypto}
}

func (s *UserService) CreateUser(ctx context.Context, user *User) (*UserEncx, error) {
	// Validate input
	if user.Email == "" || user.FirstName == "" {
		return nil, fmt.Errorf("email and first name are required")
	}

	// Use simulated function for type-safe encryption
	userEncx, err := simulateUserEncryption(ctx, s.crypto, user)
	if err != nil {
		return nil, fmt.Errorf("failed to encrypt user data: %w", err)
	}

	// In real application, save userEncx to database here
	// db.Create(userEncx)

	return userEncx, nil
}

func (s *UserService) GetUserProfile(ctx context.Context, userEncx *UserEncx) (*User, error) {
	// Use simulated function for type-safe decryption
	user, err := simulateUserDecryption(ctx, s.crypto, userEncx)
	if err != nil {
		return nil, fmt.Errorf("failed to decrypt user data: %w", err)
	}

	return user, nil
}

func (s *UserService) FindUserByEmail(ctx context.Context, email string) (string, error) {
	// Create temporary user to generate search hash
	tempUser := &User{Email: email}
	userEncx, err := simulateUserEncryption(ctx, s.crypto, tempUser)
	if err != nil {
		return "", fmt.Errorf("failed to hash email: %w", err)
	}

	// Return hash for database query
	// In real app: SELECT * FROM users WHERE email_hash = userEncx.EmailHash
	return userEncx.EmailHash, nil
}

// Pattern 2: Batch processing with generated functions
func (s *UserService) ProcessUsersBatch(ctx context.Context, users []*User) ([]*UserEncx, error) {
	results := make([]*UserEncx, 0, len(users))

	for i, user := range users {
		userEncx, err := simulateUserEncryption(ctx, s.crypto, user)
		if err != nil {
			return nil, fmt.Errorf("failed to process user %d: %w", i, err)
		}
		results = append(results, userEncx)
	}

	return results, nil
}

// Pattern 3: Database integration with generated types
type UserRepository struct {
	// db *sql.DB // Your database connection
}

func (r *UserRepository) SaveUser(ctx context.Context, userEncx *UserEncx) error {
	// Example SQL for PostgreSQL
	query := `
		INSERT INTO users (
			email_encrypted, email_hash,
			phone_encrypted, phone_hash,
			first_name_encrypted, last_name_encrypted,
			address_encrypted, ssn_hash_secure,
			dek_encrypted, key_version, metadata
		) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
	`

	// In real code, you'd execute this query with userEncx fields
	fmt.Printf("Would execute: %s\n", query)
	fmt.Printf("With encrypted data for user\n")

	return nil
}

func (r *UserRepository) FindByEmailHash(ctx context.Context, emailHash string) (*UserEncx, error) {
	query := `
		SELECT email_encrypted, email_hash, phone_encrypted, phone_hash,
			   first_name_encrypted, last_name_encrypted, address_encrypted,
			   ssn_hash_secure, dek_encrypted, key_version, metadata
		FROM users WHERE email_hash = $1
	`

	// In real code, scan results into UserEncx
	fmt.Printf("Would execute: %s\n", query)
	fmt.Printf("With emailHash: %s\n", emailHash[:16]+"...")

	// Return mock UserEncx
	return &UserEncx{
		EmailHash: emailHash,
		// ... other fields would be populated from database
	}, nil
}

/*
Code Generation Benefits:

1. **Performance**: High-performance generated code
2. **Type Safety**: Compile-time checking of all operations
3. **IDE Support**: Full autocompletion and refactoring support
4. **Maintainability**: Clear, readable generated code
5. **Debugging**: Easy to step through generated functions

Setup Instructions:

1. Install CLI:
   make build-cli && make install-cli

2. Add go:generate directives to your source files:
   //go:generate encx-gen validate -v .
   //go:generate encx-gen generate -v .

3. Generate code:
   go generate ./...

4. Use generated functions:
   - ProcessUserEncx(ctx, crypto, user) → (*UserEncx, error)
   - DecryptUserEncx(ctx, crypto, userEncx) → (*User, error)

Generated Functions Pattern:
- Process{StructName}Encx(ctx, crypto, source) → (*{StructName}Encx, error)
- Decrypt{StructName}Encx(ctx, crypto, source) → (*{StructName}, error)

Usage Example:
```go
user := &User{Email: "user@example.com"}
userEncx, err := ProcessUserEncx(ctx, crypto, user)
if err != nil {
    return err
}
// Store userEncx in database

// Later, decrypt:
decrypted, err := DecryptUserEncx(ctx, crypto, userEncx)
```

Configuration (encx.yaml):
```yaml
version: "1.0"
codegen:
  output_dir: "generated"
  default_serializer: "json"  # Options: json, gob, basic
```

When to Use:
- Production applications requiring high performance
- Large-scale data processing
- Systems with strict type safety requirements
- Applications with complex encryption patterns
- All modern Go applications using encx
*/