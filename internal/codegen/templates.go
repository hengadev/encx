package codegen

import (
	"bytes"
	"strings"
	"text/template"
	"time"
)

// TemplateData contains all data needed for code generation
type TemplateData struct {
	PackageName        string
	StructName         string
	SourceFile         string
	GeneratedTime      string
	GeneratorVersion   string
	Imports            []string
	EncryptedFields    []TemplateField
	PlainFields        []TemplateField // Non-encx fields copied as-is
	PlainFieldCopies   []string        // Copy statements for plain fields in Process function
	PlainFieldRestores []string        // Copy statements for plain fields in Decrypt function
	ProcessingSteps    []string
	DecryptionSteps    []string
}

// TemplateField represents a field in the generated struct
type TemplateField struct {
	Name      string
	Type      string
	DBColumn  string
	JSONField string
}

// Code generation template
const processTemplate = `// Code generated by encx-gen. DO NOT EDIT.
// Source: {{.SourceFile}}
// Generated: {{.GeneratedTime}}

package {{.PackageName}}

import (
	"context"
	"time"

	"github.com/hengadev/errsx"
	"github.com/hengadev/encx"
	{{range .Imports}}
	"{{.}}"
	{{end}}
)

// {{.StructName}}Encx represents the encrypted version of {{.StructName}}
type {{.StructName}}Encx struct {
	{{range .PlainFields}}
	{{.Name}} {{.Type}} ` + "`" + `db:"{{.DBColumn}}" json:"{{.JSONField}}"` + "`" + `
	{{end}}
	{{range .EncryptedFields}}
	{{.Name}} {{.Type}} ` + "`" + `db:"{{.DBColumn}}" json:"{{.JSONField}}"` + "`" + `
	{{end}}

	// Essential encryption fields
	DEKEncrypted  []byte ` + "`" + `db:"dek_encrypted" json:"dek_encrypted"` + "`" + `
	KeyVersion    int    ` + "`" + `db:"key_version" json:"key_version"` + "`" + `

	// Metadata
	Metadata      encx.EncryptionMetadata ` + "`" + `db:"metadata" json:"metadata"` + "`" + `
}

// Process{{.StructName}}Encx encrypts and hashes fields based on encx tags
func Process{{.StructName}}Encx(ctx context.Context, crypto encx.CryptoService, source *{{.StructName}}) (*{{.StructName}}Encx, error) {
	var errs errsx.Map

	// Initialize result struct
	result := &{{.StructName}}Encx{
		Metadata: encx.EncryptionMetadata{
			KEKAlias:         crypto.GetAlias(),
			EncryptionTime:   time.Now().Unix(),
			GeneratorVersion: "{{.GeneratorVersion}}",
		},
	}

	// Copy plain fields (non-encx fields)
	{{range .PlainFieldCopies}}
	{{.}}
	{{end}}

	// Generate DEK
	dek, err := crypto.GenerateDEK()
	if err != nil {
		errs.Set("DEK generation", err)
		return result, errs.AsError()
	}

	{{range .ProcessingSteps}}
	{{.}}
	{{end}}

	// Encrypt and store DEK
	result.DEKEncrypted, err = crypto.EncryptDEK(ctx, dek)
	if err != nil {
		errs.Set("DEK encryption", err)
	}

	// Get and set the current KEK version
	result.KeyVersion, err = crypto.GetCurrentKEKVersion(ctx, crypto.GetAlias())
	if err != nil {
		errs.Set("KEK version retrieval", err)
	}

	return result, errs.AsError()
}

// Decrypt{{.StructName}}Encx decrypts the encrypted struct back to original
func Decrypt{{.StructName}}Encx(ctx context.Context, crypto encx.CryptoService, source *{{.StructName}}Encx) (*{{.StructName}}, error) {
	var errs errsx.Map

	// Initialize result struct
	result := &{{.StructName}}{}

	// Copy plain fields (non-encx fields)
	{{range .PlainFieldRestores}}
	{{.}}
	{{end}}

	// Decrypt DEK
	dek, err := crypto.DecryptDEKWithVersion(ctx, source.DEKEncrypted, source.KeyVersion)
	if err != nil {
		errs.Set("DEK decryption", err)
		return result, errs.AsError()
	}

	{{range .DecryptionSteps}}
	{{.}}
	{{end}}

	return result, errs.AsError()
}
`

// Processing step templates
const encryptStepTemplate = `
	// Process {{.FieldName}} (encrypt)
	{{if .Condition}}if {{.Condition}} {
	{{end}}{{.FieldName}}Bytes, err := encx.SerializeValue(source.{{.FieldName}})
	if err != nil {
		errs.Set("{{.FieldName}} serialization", err)
	} else {
		result.{{.FieldName}}Encrypted, err = crypto.EncryptData(ctx, {{.FieldName}}Bytes, dek)
		if err != nil {
			errs.Set("{{.FieldName}} encryption", err)
		}
	}
	{{if .Condition}}}
	{{end}}`

const hashBasicStepTemplate = `
	// Process {{.FieldName}} (hash_basic)
	{{if .Condition}}if {{.Condition}} {
	{{end}}{{.FieldName}}Bytes, err := encx.SerializeValue(source.{{.FieldName}})
	if err != nil {
		errs.Set("{{.FieldName}} serialization", err)
	} else {
		result.{{.FieldName}}Hash = crypto.HashBasic(ctx, {{.FieldName}}Bytes)
	}
	{{if .Condition}}}
	{{end}}`

const hashSecureStepTemplate = `
	// Process {{.FieldName}} (hash_secure)
	{{if .Condition}}if {{.Condition}} {
	{{end}}{{.FieldName}}Bytes, err := encx.SerializeValue(source.{{.FieldName}})
	if err != nil {
		errs.Set("{{.FieldName}} serialization", err)
	} else {
		result.{{.FieldName}}HashSecure, err = crypto.HashSecure(ctx, {{.FieldName}}Bytes)
		if err != nil {
			errs.Set("{{.FieldName}} secure hash", err)
		}
	}
	{{if .Condition}}}
	{{end}}`

// Decryption step templates
const decryptStepTemplate = `
	// Decrypt {{.FieldName}}
	if len(source.{{.FieldName}}Encrypted) > 0 {
		{{.FieldName}}Bytes, err := crypto.DecryptData(ctx, source.{{.FieldName}}Encrypted, dek)
		if err != nil {
			errs.Set("{{.FieldName}} decryption", err)
		} else {
			err = encx.DeserializeValue({{.FieldName}}Bytes, &result.{{.FieldName}})
			if err != nil {
				errs.Set("{{.FieldName}} deserialization", err)
			}
		}
	}`

// TemplateEngine manages code generation templates
type TemplateEngine struct {
	processTemplate *template.Template
}

// NewTemplateEngine creates a new template engine
func NewTemplateEngine() (*TemplateEngine, error) {
	tmpl, err := template.New("process").Parse(processTemplate)
	if err != nil {
		return nil, err
	}

	return &TemplateEngine{
		processTemplate: tmpl,
	}, nil
}

// GenerateCode generates code for a struct using the template
func (te *TemplateEngine) GenerateCode(data TemplateData) ([]byte, error) {
	var buf bytes.Buffer
	err := te.processTemplate.Execute(&buf, data)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// GenerationConfig holds general generation settings
type GenerationConfig struct {
	OutputSuffix string
	PackageName  string
}

// BuildTemplateData builds template data from struct info
func BuildTemplateData(structInfo StructInfo, config GenerationConfig) TemplateData {
	// Hardcoded imports that are always included in the template
	hardcodedImports := map[string]bool{
		"context":                     true,
		"time":                        true,
		"github.com/hengadev/errsx":   true,
		"github.com/hengadev/encx":    true,
	}

	// Collect required imports from the struct, excluding hardcoded ones
	var imports []string
	for _, importPath := range structInfo.RequiredImports {
		if !hardcodedImports[importPath] {
			imports = append(imports, importPath)
		}
	}

	data := TemplateData{
		PackageName:        structInfo.PackageName,
		StructName:         structInfo.StructName,
		SourceFile:         structInfo.SourceFile,
		GeneratedTime:      time.Now().Format(time.RFC3339),
		GeneratorVersion:   "1.0.0",
		Imports:            imports,
		EncryptedFields:    []TemplateField{},
		PlainFields:        []TemplateField{},
		PlainFieldCopies:   []string{},
		PlainFieldRestores: []string{},
		ProcessingSteps:    []string{},
		DecryptionSteps:    []string{},
	}

	// Process ALL fields (both with and without encx tags)
	for _, field := range structInfo.Fields {
		if len(field.EncxTags) > 0 {
			// Field has encx tags - apply encryption/hashing transformations
			processFieldForTemplate(&data, field)
		} else {
			// Field has no encx tags - copy as-is
			processPlainFieldForTemplate(&data, field)
		}
	}

	return data
}

// processPlainFieldForTemplate processes a field without encx tags
func processPlainFieldForTemplate(data *TemplateData, field FieldInfo) {
	// Skip companion fields (these are generated fields, not source fields)
	// Companion fields end with: Encrypted, Hash, HashSecure
	if isCompanionField(field.Name) {
		return
	}

	// Add field to PlainFields (will be included in generated struct as-is)
	plainField := TemplateField{
		Name:      field.Name,
		Type:      field.Type,
		DBColumn:  strings.ToLower(field.Name),
		JSONField: strings.ToLower(field.Name),
	}
	data.PlainFields = append(data.PlainFields, plainField)

	// Add copy statement for Process function (source -> result)
	copyStmt := "result." + field.Name + " = source." + field.Name
	data.PlainFieldCopies = append(data.PlainFieldCopies, copyStmt)

	// Add restore statement for Decrypt function (source -> result)
	restoreStmt := "result." + field.Name + " = source." + field.Name
	data.PlainFieldRestores = append(data.PlainFieldRestores, restoreStmt)
}

// isCompanionField checks if a field name looks like a generated companion field
func isCompanionField(fieldName string) bool {
	return strings.HasSuffix(fieldName, "Encrypted") ||
		strings.HasSuffix(fieldName, "Hash") ||
		strings.HasSuffix(fieldName, "HashSecure")
}

// processFieldForTemplate processes a field and adds template data
func processFieldForTemplate(data *TemplateData, field FieldInfo) {
	hasEncryption := false

	for _, tag := range field.EncxTags {
		switch tag {
		case "encrypt":
			hasEncryption = true
			// Add encrypted field to struct
			encryptedField := TemplateField{
				Name:      field.Name + "Encrypted",
				Type:      "[]byte",
				DBColumn:  strings.ToLower(field.Name) + "_encrypted",
				JSONField: strings.ToLower(field.Name) + "_encrypted",
			}
			data.EncryptedFields = append(data.EncryptedFields, encryptedField)

			// Add processing step
			step := generateProcessingStep(encryptStepTemplate, field.Name, field.Type)
			data.ProcessingSteps = append(data.ProcessingSteps, step)

		case "hash_basic":
			// Add hash field to struct
			hashField := TemplateField{
				Name:      field.Name + "Hash",
				Type:      "string",
				DBColumn:  strings.ToLower(field.Name) + "_hash",
				JSONField: strings.ToLower(field.Name) + "_hash",
			}
			data.EncryptedFields = append(data.EncryptedFields, hashField)

			// Add processing step
			step := generateProcessingStep(hashBasicStepTemplate, field.Name, field.Type)
			data.ProcessingSteps = append(data.ProcessingSteps, step)

		case "hash_secure":
			// Add secure hash field to struct
			hashField := TemplateField{
				Name:      field.Name + "HashSecure",
				Type:      "string",
				DBColumn:  strings.ToLower(field.Name) + "_hash_secure",
				JSONField: strings.ToLower(field.Name) + "_hash_secure",
			}
			data.EncryptedFields = append(data.EncryptedFields, hashField)

			// Add processing step
			step := generateProcessingStep(hashSecureStepTemplate, field.Name, field.Type)
			data.ProcessingSteps = append(data.ProcessingSteps, step)
		}
	}

	// Add decryption step if field has encryption
	if hasEncryption {
		decryptStep := generateProcessingStep(decryptStepTemplate, field.Name, field.Type)
		data.DecryptionSteps = append(data.DecryptionSteps, decryptStep)
	}
}

// generateProcessingStep generates a processing step from template
func generateProcessingStep(stepTemplate, fieldName, fieldType string) string {
	tmpl, _ := template.New("step").Parse(stepTemplate)

	stepData := struct {
		FieldName string
		Condition string
	}{
		FieldName: fieldName,
		Condition: getNonZeroCondition(fieldName, fieldType),
	}

	var buf bytes.Buffer
	tmpl.Execute(&buf, stepData)
	return buf.String()
}

// getNonZeroCondition returns a condition expression to check if a field should be processed
// Returns empty string if the field should always be processed (no condition needed)
func getNonZeroCondition(fieldName, typeName string) string {
	// Pointer types - check for nil
	if strings.HasPrefix(typeName, "*") {
		return "source." + fieldName + " != nil"
	}

	// Special struct types with semantic "not set" values
	if strings.Contains(typeName, "uuid.UUID") {
		return "source." + fieldName + " != uuid.Nil"
	}
	if strings.Contains(typeName, "time.Time") {
		return "!source." + fieldName + ".IsZero()"
	}

	// All other types (string, int, bool, etc.) should always be processed
	// Empty strings, zero integers, and false booleans are valid values
	return ""
}
