package codegen

import (
	"bytes"
	"strings"
	"text/template"
	"time"
)

// TemplateData contains all data needed for code generation
type TemplateData struct {
	PackageName            string
	StructName             string
	SourceFile             string
	GeneratedTime          string
	SerializerType         string
	SerializerFactory      string
	SerializerFromMetadata string
	GeneratorVersion       string
	Imports                []string
	EncryptedFields        []TemplateField
	ProcessingSteps        []string
	DecryptionSteps        []string
}

// TemplateField represents a field in the generated struct
type TemplateField struct {
	Name      string
	Type      string
	DBColumn  string
	JSONField string
}

// Code generation template
const processTemplate = `// Code generated by encx-gen. DO NOT EDIT.
// Source: {{.SourceFile}}
// Generated: {{.GeneratedTime}}

package {{.PackageName}}

import (
	"context"
	"time"

	"github.com/hengadev/errsx"
	"github.com/hengadev/encx"
	"github.com/hengadev/encx/internal/metadata"
	{{range .Imports}}
	"{{.}}"
	{{end}}
)

// {{.StructName}}Encx represents the encrypted version of {{.StructName}}
type {{.StructName}}Encx struct {
	{{range .EncryptedFields}}
	{{.Name}} {{.Type}} ` + "`" + `db:"{{.DBColumn}}" json:"{{.JSONField}}"` + "`" + `
	{{end}}

	// Essential encryption fields
	DEKEncrypted  []byte ` + "`" + `db:"dek_encrypted" json:"dek_encrypted"` + "`" + `
	KeyVersion    int    ` + "`" + `db:"key_version" json:"key_version"` + "`" + `

	// Metadata
	Metadata      metadata.EncryptionMetadata ` + "`" + `db:"metadata" json:"metadata"` + "`" + `
}

// Process{{.StructName}}Encx encrypts and hashes fields based on encx tags
func Process{{.StructName}}Encx(ctx context.Context, crypto *encx.Crypto, source *{{.StructName}}) (*{{.StructName}}Encx, error) {
	var errs errsx.Map

	// Initialize result struct
	result := &{{.StructName}}Encx{
		Metadata: metadata.EncryptionMetadata{
			SerializerType:   "{{.SerializerType}}",
			KEKAlias:         crypto.GetAlias(),
			EncryptionTime:   time.Now().Unix(),
			GeneratorVersion: "{{.GeneratorVersion}}",
		},
	}

	// Generate DEK
	dek, err := crypto.GenerateDEK()
	if err != nil {
		errs.Set("DEK generation", err)
		return result, errs.AsError()
	}

	// Initialize serializer
	serializer := {{.SerializerFactory}}

	{{range .ProcessingSteps}}
	{{.}}
	{{end}}

	// Encrypt and store DEK
	result.DEKEncrypted, err = crypto.EncryptDEK(ctx, dek)
	if err != nil {
		errs.Set("DEK encryption", err)
	}

	return result, errs.AsError()
}

// Decrypt{{.StructName}}Encx decrypts the encrypted struct back to original
func Decrypt{{.StructName}}Encx(ctx context.Context, crypto *encx.Crypto, source *{{.StructName}}Encx) (*{{.StructName}}, error) {
	var errs errsx.Map

	// Initialize result struct
	result := &{{.StructName}}{}

	// Decrypt DEK
	dek, err := crypto.DecryptDEKWithVersion(ctx, source.DEKEncrypted, source.KeyVersion)
	if err != nil {
		errs.Set("DEK decryption", err)
		return result, errs.AsError()
	}

	// Initialize serializer (from metadata)
	serializer := {{.SerializerFromMetadata}}

	{{range .DecryptionSteps}}
	{{.}}
	{{end}}

	return result, errs.AsError()
}
`

// Processing step templates
const encryptStepTemplate = `
	// Process {{.FieldName}} (encrypt)
	if source.{{.FieldName}} != {{.ZeroValue}} {
		{{.FieldName}}Bytes, err := serializer.Serialize(source.{{.FieldName}})
		if err != nil {
			errs.Set("{{.FieldName}} serialization", err)
		} else {
			result.{{.FieldName}}Encrypted, err = crypto.EncryptData(ctx, {{.FieldName}}Bytes, dek)
			if err != nil {
				errs.Set("{{.FieldName}} encryption", err)
			}
		}
	}`

const hashBasicStepTemplate = `
	// Process {{.FieldName}} (hash_basic)
	if source.{{.FieldName}} != {{.ZeroValue}} {
		{{.FieldName}}Bytes, err := serializer.Serialize(source.{{.FieldName}})
		if err != nil {
			errs.Set("{{.FieldName}} serialization", err)
		} else {
			result.{{.FieldName}}Hash = crypto.HashBasic(ctx, {{.FieldName}}Bytes)
		}
	}`

const hashSecureStepTemplate = `
	// Process {{.FieldName}} (hash_secure)
	if source.{{.FieldName}} != {{.ZeroValue}} {
		{{.FieldName}}Bytes, err := serializer.Serialize(source.{{.FieldName}})
		if err != nil {
			errs.Set("{{.FieldName}} serialization", err)
		} else {
			result.{{.FieldName}}HashSecure, err = crypto.HashSecure(ctx, {{.FieldName}}Bytes)
			if err != nil {
				errs.Set("{{.FieldName}} secure hash", err)
			}
		}
	}`

// TemplateEngine manages code generation templates
type TemplateEngine struct {
	processTemplate *template.Template
}

// NewTemplateEngine creates a new template engine
func NewTemplateEngine() (*TemplateEngine, error) {
	tmpl, err := template.New("process").Parse(processTemplate)
	if err != nil {
		return nil, err
	}

	return &TemplateEngine{
		processTemplate: tmpl,
	}, nil
}

// GenerateCode generates code for a struct using the template
func (te *TemplateEngine) GenerateCode(data TemplateData) ([]byte, error) {
	var buf bytes.Buffer
	err := te.processTemplate.Execute(&buf, data)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// GenerationConfig holds general generation settings
type GenerationConfig struct {
	OutputSuffix      string
	FunctionPrefix    string
	PackageName       string
	DefaultSerializer string
}

// BuildTemplateData builds template data from struct info
func BuildTemplateData(structInfo StructInfo, config GenerationConfig) TemplateData {
	data := TemplateData{
		PackageName:      structInfo.PackageName,
		StructName:       structInfo.StructName,
		SourceFile:       structInfo.SourceFile,
		GeneratedTime:    time.Now().Format(time.RFC3339),
		SerializerType:   config.DefaultSerializer,
		GeneratorVersion: "1.0.0",
		Imports:          []string{},
		EncryptedFields:  []TemplateField{},
		ProcessingSteps:  []string{},
		DecryptionSteps:  []string{},
	}

	// Generate serializer factory based on type
	switch config.DefaultSerializer {
	case "json":
		data.SerializerFactory = "&serialization.JSONSerializer{}"
		data.SerializerFromMetadata = "&serialization.JSONSerializer{}"
		data.Imports = append(data.Imports, "github.com/hengadev/encx/internal/serialization")
	case "gob":
		data.SerializerFactory = "&serialization.GOBSerializer{}"
		data.SerializerFromMetadata = "&serialization.GOBSerializer{}"
		data.Imports = append(data.Imports, "github.com/hengadev/encx/internal/serialization")
	case "basic":
		data.SerializerFactory = "&serialization.BasicTypeSerializer{}"
		data.SerializerFromMetadata = "&serialization.BasicTypeSerializer{}"
		data.Imports = append(data.Imports, "github.com/hengadev/encx/internal/serialization")
	}

	// Process each field with encx tags
	for _, field := range structInfo.Fields {
		if len(field.EncxTags) > 0 {
			processFieldForTemplate(&data, field)
		}
	}

	return data
}

// processFieldForTemplate processes a field and adds template data
func processFieldForTemplate(data *TemplateData, field FieldInfo) {
	for _, tag := range field.EncxTags {
		switch tag {
		case "encrypt":
			// Add encrypted field to struct
			encryptedField := TemplateField{
				Name:      field.Name + "Encrypted",
				Type:      "[]byte",
				DBColumn:  strings.ToLower(field.Name) + "_encrypted",
				JSONField: strings.ToLower(field.Name) + "_encrypted",
			}
			data.EncryptedFields = append(data.EncryptedFields, encryptedField)

			// Add processing step
			step := generateProcessingStep(encryptStepTemplate, field.Name, field.Type)
			data.ProcessingSteps = append(data.ProcessingSteps, step)

		case "hash_basic":
			// Add hash field to struct
			hashField := TemplateField{
				Name:      field.Name + "Hash",
				Type:      "string",
				DBColumn:  strings.ToLower(field.Name) + "_hash",
				JSONField: strings.ToLower(field.Name) + "_hash",
			}
			data.EncryptedFields = append(data.EncryptedFields, hashField)

			// Add processing step
			step := generateProcessingStep(hashBasicStepTemplate, field.Name, field.Type)
			data.ProcessingSteps = append(data.ProcessingSteps, step)

		case "hash_secure":
			// Add secure hash field to struct
			hashField := TemplateField{
				Name:      field.Name + "HashSecure",
				Type:      "string",
				DBColumn:  strings.ToLower(field.Name) + "_hash_secure",
				JSONField: strings.ToLower(field.Name) + "_hash_secure",
			}
			data.EncryptedFields = append(data.EncryptedFields, hashField)

			// Add processing step
			step := generateProcessingStep(hashSecureStepTemplate, field.Name, field.Type)
			data.ProcessingSteps = append(data.ProcessingSteps, step)
		}
	}
}

// generateProcessingStep generates a processing step from template
func generateProcessingStep(stepTemplate, fieldName, fieldType string) string {
	tmpl, _ := template.New("step").Parse(stepTemplate)

	stepData := struct {
		FieldName string
		ZeroValue string
	}{
		FieldName: fieldName,
		ZeroValue: getZeroValue(fieldType),
	}

	var buf bytes.Buffer
	tmpl.Execute(&buf, stepData)
	return buf.String()
}

// getZeroValue returns the zero value for a type
func getZeroValue(typeName string) string {
	switch typeName {
	case "string":
		return "\"\""
	case "int", "int8", "int16", "int32", "int64":
		return "0"
	case "uint", "uint8", "uint16", "uint32", "uint64":
		return "0"
	case "float32", "float64":
		return "0"
	case "bool":
		return "false"
	default:
		return "nil"
	}
}