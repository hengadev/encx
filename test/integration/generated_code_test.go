package integration_test

import (
	"context"
	"os"
	"path/filepath"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"github.com/stretchr/testify/suite"

	"github.com/hengadev/encx"
	"github.com/hengadev/encx/internal/codegen"
)

// GeneratedCodeIntegrationTestSuite tests end-to-end code generation and usage
type GeneratedCodeIntegrationTestSuite struct {
	suite.Suite
	tempDir string
	crypto  *encx.Crypto
	ctx     context.Context
}

// SetupSuite creates a temporary directory and crypto instance
func (suite *GeneratedCodeIntegrationTestSuite) SetupSuite() {
	suite.ctx = context.Background()

	// Create temporary directory for test files
	tempDir, err := os.MkdirTemp("", "encx-integration-test-*")
	require.NoError(suite.T(), err)
	suite.tempDir = tempDir

	// Create crypto instance with simple test KMS
	suite.crypto, err = encx.NewCrypto(suite.ctx,
		encx.WithKMSService(encx.NewSimpleTestKMS()),
		encx.WithKEKAlias("integration-test-key"),
		encx.WithPepper([]byte("test-pepper-exactly-32-bytes-OK!")),
	)
	require.NoError(suite.T(), err)
}

// TearDownSuite cleans up the temporary directory
func (suite *GeneratedCodeIntegrationTestSuite) TearDownSuite() {
	if suite.tempDir != "" {
		os.RemoveAll(suite.tempDir)
	}
}

// TestEndToEndCodeGeneration tests the complete flow from struct definition to encryption
func (suite *GeneratedCodeIntegrationTestSuite) TestEndToEndCodeGeneration() {
	// Create source file with test struct
	sourceFile := filepath.Join(suite.tempDir, "user.go")
	sourceContent := `package integration_test

// User represents a user with encrypted fields for integration testing
type User struct {
	ID       int    ` + "`json:\"id\"`" + `
	Name     string ` + "`json:\"name\"`" + `
	Email    string ` + "`json:\"email\" encx:\"encrypt,hash_basic\"`" + `
	Phone    string ` + "`json:\"phone\" encx:\"encrypt\"`" + `
	SSN      string ` + "`json:\"ssn\" encx:\"hash_secure\"`" + `
	Password string ` + "`json:\"password\" encx:\"hash_secure\"`" + `

	// Companion fields for encryption/hashing
	EmailEncrypted    []byte ` + "`json:\"email_encrypted\" db:\"email_encrypted\"`" + `
	EmailHash         string ` + "`json:\"email_hash\" db:\"email_hash\"`" + `
	PhoneEncrypted    []byte ` + "`json:\"phone_encrypted\" db:\"phone_encrypted\"`" + `
	SSNHashSecure     string ` + "`json:\"ssn_hash_secure\" db:\"ssn_hash_secure\"`" + `
	PasswordHashSecure string ` + "`json:\"password_hash_secure\" db:\"password_hash_secure\"`" + `
}
`

	err := os.WriteFile(sourceFile, []byte(sourceContent), 0644)
	require.NoError(suite.T(), err)

	// Run code generation
	err = suite.generateCode(suite.tempDir)
	require.NoError(suite.T(), err)

	// Verify generated file exists
	generatedFile := filepath.Join(suite.tempDir, "user_encx.go")
	_, err = os.Stat(generatedFile)
	require.NoError(suite.T(), err, "Generated file should exist")

	// Read and verify generated content
	content, err := os.ReadFile(generatedFile)
	require.NoError(suite.T(), err)

	contentStr := string(content)

	// Verify basic structure
	assert.Contains(suite.T(), contentStr, "Code generated by encx-gen. DO NOT EDIT.")
	assert.Contains(suite.T(), contentStr, "package integration_test")
	assert.Contains(suite.T(), contentStr, "type UserEncx struct")
	assert.Contains(suite.T(), contentStr, "func ProcessUserEncx")
	assert.Contains(suite.T(), contentStr, "func DecryptUserEncx")

	// Verify all encrypted/hashed fields are included
	assert.Contains(suite.T(), contentStr, "EmailEncrypted []byte")
	assert.Contains(suite.T(), contentStr, "EmailHash string")
	assert.Contains(suite.T(), contentStr, "PhoneEncrypted []byte")
	assert.Contains(suite.T(), contentStr, "SSNHashSecure string")
	assert.Contains(suite.T(), contentStr, "PasswordHashSecure string")

	// Verify crypto operations are included
	assert.Contains(suite.T(), contentStr, "crypto.EncryptData(ctx, EmailBytes, dek)")
	assert.Contains(suite.T(), contentStr, "crypto.HashBasic(ctx, EmailBytes)")
	assert.Contains(suite.T(), contentStr, "crypto.EncryptData(ctx, PhoneBytes, dek)")
	assert.Contains(suite.T(), contentStr, "crypto.HashSecure(ctx, SSNBytes)")
	assert.Contains(suite.T(), contentStr, "crypto.HashSecure(ctx, PasswordBytes)")

	// Verify decryption operations (only for encrypted fields)
	assert.Contains(suite.T(), contentStr, "crypto.DecryptData(ctx, source.EmailEncrypted, dek)")
	assert.Contains(suite.T(), contentStr, "crypto.DecryptData(ctx, source.PhoneEncrypted, dek)")
	// Hash-only fields should not have decryption
	assert.NotContains(suite.T(), contentStr, "crypto.DecryptData(ctx, source.SSNHashSecure, dek)")
	assert.NotContains(suite.T(), contentStr, "crypto.DecryptData(ctx, source.PasswordHashSecure, dek)")
}

// TestGeneratedCodeValidation tests validation of generated code
func (suite *GeneratedCodeIntegrationTestSuite) TestGeneratedCodeValidation() {
	// Create source file with validation errors
	sourceFile := filepath.Join(suite.tempDir, "invalid.go")
	sourceContent := `package integration_test

type InvalidUser struct {
	// Invalid: both hash types
	Email string ` + "`encx:\"hash_basic,hash_secure\"`" + `

	// Missing companion field for encryption
	Phone string ` + "`encx:\"encrypt\"`" + `

	// Wrong type companion field
	Name string ` + "`encx:\"encrypt\"`" + `
	NameEncrypted string ` + "`db:\"name_encrypted\"`" + ` // Should be []byte
}
`

	err := os.WriteFile(sourceFile, []byte(sourceContent), 0644)
	require.NoError(suite.T(), err)

	// Run struct discovery and validation
	discoveryConfig := &codegen.DiscoveryConfig{}
	structs, err := codegen.DiscoverStructs(suite.tempDir, discoveryConfig)
	require.NoError(suite.T(), err)

	assert.Len(suite.T(), structs, 1)
	invalidStruct := structs[0]
	assert.Equal(suite.T(), "InvalidUser", invalidStruct.StructName)

	// Verify validation errors were detected
	hasValidationErrors := false
	for _, field := range invalidStruct.Fields {
		if !field.IsValid {
			hasValidationErrors = true
			assert.NotEmpty(suite.T(), field.ValidationErrors)
		}
	}
	assert.True(suite.T(), hasValidationErrors, "Should have validation errors")

	// Code generation should skip invalid structs
	err = suite.generateCode(suite.tempDir)
	require.NoError(suite.T(), err)

	// Verify no file was generated for invalid struct
	generatedFile := filepath.Join(suite.tempDir, "invalid_encx.go")
	_, err = os.Stat(generatedFile)
	assert.True(suite.T(), os.IsNotExist(err), "Should not generate file for invalid struct")
}

// TestComplexStructGeneration tests generation for complex structs with all tag combinations
func (suite *GeneratedCodeIntegrationTestSuite) TestComplexStructGeneration() {
	sourceFile := filepath.Join(suite.tempDir, "complex.go")
	sourceContent := `package integration_test

type ComplexUser struct {
	ID             int    ` + "`json:\"id\"`" + `

	// Encrypt only
	Phone          string ` + "`encx:\"encrypt\"`" + `
	PhoneEncrypted []byte ` + "`json:\"phone_encrypted\"`" + `

	// Hash basic only
	Username       string ` + "`encx:\"hash_basic\"`" + `
	UsernameHash   string ` + "`json:\"username_hash\"`" + `

	// Hash secure only
	SSN            string ` + "`encx:\"hash_secure\"`" + `
	SSNHashSecure  string ` + "`json:\"ssn_hash_secure\"`" + `

	// Encrypt + Hash basic
	Email          string ` + "`encx:\"encrypt,hash_basic\"`" + `
	EmailEncrypted []byte ` + "`json:\"email_encrypted\"`" + `
	EmailHash      string ` + "`json:\"email_hash\"`" + `

	// Encrypt + Hash secure
	CreditCard         string ` + "`encx:\"encrypt,hash_secure\"`" + `
	CreditCardEncrypted []byte ` + "`json:\"credit_card_encrypted\"`" + `
	CreditCardHashSecure string ` + "`json:\"credit_card_hash_secure\"`" + `

	// No encx tags
	Name           string ` + "`json:\"name\"`" + `
}
`

	err := os.WriteFile(sourceFile, []byte(sourceContent), 0644)
	require.NoError(suite.T(), err)

	err = suite.generateCode(suite.tempDir)
	require.NoError(suite.T(), err)

	generatedFile := filepath.Join(suite.tempDir, "complex_encx.go")
	content, err := os.ReadFile(generatedFile)
	require.NoError(suite.T(), err)

	contentStr := string(content)

	// Verify all encrypted/hashed fields are included
	assert.Contains(suite.T(), contentStr, "PhoneEncrypted []byte")
	assert.Contains(suite.T(), contentStr, "UsernameHash string")
	assert.Contains(suite.T(), contentStr, "SSNHashSecure string")
	assert.Contains(suite.T(), contentStr, "EmailEncrypted []byte")
	assert.Contains(suite.T(), contentStr, "EmailHash string")
	assert.Contains(suite.T(), contentStr, "CreditCardEncrypted []byte")
	assert.Contains(suite.T(), contentStr, "CreditCardHashSecure string")

	// Verify processing logic for each field type
	assert.Contains(suite.T(), contentStr, "crypto.EncryptData(ctx, PhoneBytes, dek)")
	assert.Contains(suite.T(), contentStr, "crypto.HashBasic(ctx, UsernameBytes)")
	assert.Contains(suite.T(), contentStr, "crypto.HashSecure(ctx, SSNBytes)")
	assert.Contains(suite.T(), contentStr, "crypto.EncryptData(ctx, EmailBytes, dek)")
	assert.Contains(suite.T(), contentStr, "crypto.HashBasic(ctx, EmailBytes)")
	assert.Contains(suite.T(), contentStr, "crypto.EncryptData(ctx, CreditCardBytes, dek)")
	assert.Contains(suite.T(), contentStr, "crypto.HashSecure(ctx, CreditCardBytes)")

	// Verify decryption logic (only for encrypted fields)
	assert.Contains(suite.T(), contentStr, "crypto.DecryptData(ctx, source.PhoneEncrypted, dek)")
	assert.Contains(suite.T(), contentStr, "crypto.DecryptData(ctx, source.EmailEncrypted, dek)")
	assert.Contains(suite.T(), contentStr, "crypto.DecryptData(ctx, source.CreditCardEncrypted, dek)")

	// Verify no decryption for hash-only fields
	assert.NotContains(suite.T(), contentStr, "crypto.DecryptData(ctx, source.UsernameHash, dek)")
	assert.NotContains(suite.T(), contentStr, "crypto.DecryptData(ctx, source.SSNHashSecure, dek)")
}

// TestIncrementalGeneration tests that code generation only regenerates when needed
func (suite *GeneratedCodeIntegrationTestSuite) TestIncrementalGeneration() {
	sourceFile := filepath.Join(suite.tempDir, "incremental.go")
	sourceContent := `package integration_test

type IncrementalUser struct {
	Email string ` + "`encx:\"encrypt\"`" + `
	EmailEncrypted []byte
}
`

	err := os.WriteFile(sourceFile, []byte(sourceContent), 0644)
	require.NoError(suite.T(), err)

	// First generation
	err = suite.generateCode(suite.tempDir)
	require.NoError(suite.T(), err)

	generatedFile := filepath.Join(suite.tempDir, "incremental_encx.go")
	info1, err := os.Stat(generatedFile)
	require.NoError(suite.T(), err)

	// Second generation without changes should not modify the file
	err = suite.generateCode(suite.tempDir)
	require.NoError(suite.T(), err)

	info2, err := os.Stat(generatedFile)
	require.NoError(suite.T(), err)

	// File modification time should be the same (file not regenerated)
	assert.Equal(suite.T(), info1.ModTime(), info2.ModTime())
}

// generateCode is a helper that runs code generation on a directory
func (suite *GeneratedCodeIntegrationTestSuite) generateCode(dir string) error {
	config := &codegen.DiscoveryConfig{}
	structs, err := codegen.DiscoverStructs(dir, config)
	if err != nil {
		return err
	}

	templateEngine, err := codegen.NewTemplateEngine()
	if err != nil {
		return err
	}

	codegenConfig := codegen.GenerationConfig{
		OutputSuffix:   "_encx",
		FunctionPrefix: "Process",
		PackageName:    "integration_test",
	}

	for _, structInfo := range structs {
		// Skip structs with validation errors
		hasErrors := false
		for _, field := range structInfo.Fields {
			if !field.IsValid {
				hasErrors = true
				break
			}
		}
		if hasErrors {
			continue
		}

		// Generate the file
		baseName := filepath.Base(structInfo.SourceFile)
		baseName = baseName[:len(baseName)-3] // Remove .go extension
		outputFileName := filepath.Join(dir, baseName+codegenConfig.OutputSuffix+".go")

		templateData := codegen.BuildTemplateData(structInfo, codegenConfig)
		code, err := templateEngine.GenerateCode(templateData)
		if err != nil {
			return err
		}

		err = os.WriteFile(outputFileName, code, 0644)
		if err != nil {
			return err
		}
	}

	return nil
}

// TestSuite entry point
func TestGeneratedCodeIntegrationSuite(t *testing.T) {
	suite.Run(t, new(GeneratedCodeIntegrationTestSuite))
}