package codegen_test

import (
	"os"
	"path/filepath"
	"strings"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"

	"github.com/hengadev/encx/internal/codegen"
)

// generateCodeForDirectory is a helper function that simulates the CLI generation process
func generateCodeForDirectory(dir string) error {
	config := &codegen.DiscoveryConfig{}
	structs, err := codegen.DiscoverStructs(dir, config)
	if err != nil {
		return err
	}

	templateEngine, err := codegen.NewTemplateEngine()
	if err != nil {
		return err
	}

	codegenConfig := codegen.GenerationConfig{
		OutputSuffix: "_encx",
		PackageName:  "encx",
	}

	for _, structInfo := range structs {
		// Skip structs with validation errors
		hasErrors := false
		for _, field := range structInfo.Fields {
			if !field.IsValid {
				hasErrors = true
				break
			}
		}
		if hasErrors {
			continue
		}

		// Generate the file path correctly
		baseName := strings.TrimSuffix(filepath.Base(structInfo.SourceFile), ".go")
		outputFileName := filepath.Join(dir, baseName+codegenConfig.OutputSuffix+".go")

		templateData := codegen.BuildTemplateData(structInfo, codegenConfig)
		code, err := templateEngine.GenerateCode(templateData)
		if err != nil {
			return err
		}

		err = os.WriteFile(outputFileName, code, 0644)
		if err != nil {
			return err
		}
	}

	return nil
}

func TestEndToEndCodeGeneration(t *testing.T) {
	// Create temporary directory for test project
	tempDir := t.TempDir()

	// Create source file with test struct
	sourceFile := filepath.Join(tempDir, "user.go")
	err := os.WriteFile(sourceFile, []byte(`package test

// User represents a user with encrypted fields for integration testing
type User struct {
	ID    int    `+"`json:\"id\"`"+`
	Email string `+"`json:\"email\" encx:\"encrypt,hash_basic\"`"+`
	Phone string `+"`json:\"phone\" encx:\"encrypt\"`"+`
	SSN   string `+"`json:\"ssn\" encx:\"hash_secure\"`"+`
	Name  string `+"`json:\"name\"`"+`

	// Companion fields for encryption/hashing
	EmailEncrypted []byte `+"`json:\"email_encrypted\" db:\"email_encrypted\"`"+`
	EmailHash      string `+"`json:\"email_hash\" db:\"email_hash\"`"+`
	PhoneEncrypted []byte `+"`json:\"phone_encrypted\" db:\"phone_encrypted\"`"+`
	SSNHashSecure  string `+"`json:\"ssn_hash_secure\" db:\"ssn_hash_secure\"`"+`
}
`), 0644)
	require.NoError(t, err)

	// Run code generation using internal APIs directly
	err = generateCodeForDirectory(tempDir)
	require.NoError(t, err)

	// Verify generated file exists
	generatedFile := filepath.Join(tempDir, "user_encx.go")
	_, err = os.Stat(generatedFile)
	require.NoError(t, err, "Generated file should exist")

	// Read and verify generated content
	content, err := os.ReadFile(generatedFile)
	require.NoError(t, err)

	contentStr := string(content)

	// Verify generated code structure
	assert.Contains(t, contentStr, "Code generated by encx-gen. DO NOT EDIT.")
	assert.Contains(t, contentStr, "package test")
	assert.Contains(t, contentStr, "type UserEncx struct")
	assert.Contains(t, contentStr, "func ProcessUserEncx")
	assert.Contains(t, contentStr, "func DecryptUserEncx")

	// Verify struct fields
	assert.Contains(t, contentStr, "EmailEncrypted []byte")
	assert.Contains(t, contentStr, "EmailHash string")
	assert.Contains(t, contentStr, "PhoneEncrypted []byte")
	assert.Contains(t, contentStr, "SSNHashSecure string")

	// Verify encryption logic
	assert.Contains(t, contentStr, "crypto.EncryptData(ctx, EmailBytes, dek)")
	assert.Contains(t, contentStr, "crypto.HashBasic(ctx, EmailBytes)")
	assert.Contains(t, contentStr, "crypto.EncryptData(ctx, PhoneBytes, dek)")
	assert.Contains(t, contentStr, "crypto.HashSecure(ctx, SSNBytes)")

	// Verify decryption logic
	assert.Contains(t, contentStr, "crypto.DecryptData(ctx, source.EmailEncrypted, dek)")
	assert.Contains(t, contentStr, "crypto.DecryptData(ctx, source.PhoneEncrypted, dek)")
	// SSN should not have decryption (hash-only)
	assert.NotContains(t, contentStr, "crypto.DecryptData(ctx, source.SSNHashSecure, dek)")

	// Verify error handling
	assert.Contains(t, contentStr, "errsx.Map")
	assert.Contains(t, contentStr, "errs.AsError()")

}

func TestStructDiscoveryIntegration(t *testing.T) {
	tempDir := t.TempDir()

	// Create multiple files with different structs
	file1 := filepath.Join(tempDir, "models.go")
	err := os.WriteFile(file1, []byte(`package test

type User struct {
	Email string `+"`json:\"email\" encx:\"encrypt\"`"+`
	EmailEncrypted []byte `+"`json:\"email_encrypted\"`"+`
}

type Admin struct {
	Username string `+"`json:\"username\" encx:\"hash_basic\"`"+`
	UsernameHash string `+"`json:\"username_hash\"`"+`
}
`), 0644)
	require.NoError(t, err)

	file2 := filepath.Join(tempDir, "products.go")
	err = os.WriteFile(file2, []byte(`package test

type Product struct {
	Name string `+"`json:\"name\"`"+` // No encx tags
}

type SecureProduct struct {
	Description string `+"`json:\"description\" encx:\"encrypt\"`"+`
	DescriptionEncrypted []byte `+"`json:\"description_encrypted\"`"+`
}
`), 0644)
	require.NoError(t, err)

	// Discover structs
	config := &codegen.DiscoveryConfig{}
	structs, err := codegen.DiscoverStructs(tempDir, config)
	require.NoError(t, err)

	// Should find 3 structs with encx tags: User, Admin, SecureProduct
	assert.Len(t, structs, 3)

	structNames := make([]string, len(structs))
	for i, s := range structs {
		structNames[i] = s.StructName
	}

	assert.Contains(t, structNames, "User")
	assert.Contains(t, structNames, "Admin")
	assert.Contains(t, structNames, "SecureProduct")
	assert.NotContains(t, structNames, "Product") // No encx tags
}

func TestValidationIntegration(t *testing.T) {
	tempDir := t.TempDir()

	// Create file with validation errors
	sourceFile := filepath.Join(tempDir, "invalid.go")
	err := os.WriteFile(sourceFile, []byte(`package test

type InvalidUser struct {
	// Invalid: both hash types
	Email string `+"`json:\"email\" encx:\"hash_basic,hash_secure\"`"+`

	// Missing companion field
	Phone string `+"`json:\"phone\" encx:\"encrypt\"`"+`

	// Wrong type companion field
	Name string `+"`json:\"name\" encx:\"encrypt\"`"+`
	NameEncrypted string `+"`json:\"name_encrypted\"`"+` // Should be []byte
}
`), 0644)
	require.NoError(t, err)

	// Run struct discovery and validation
	config := &codegen.DiscoveryConfig{}
	structs, err := codegen.DiscoverStructs(tempDir, config)
	require.NoError(t, err)

	assert.Len(t, structs, 1)
	invalidStruct := structs[0]
	assert.Equal(t, "InvalidUser", invalidStruct.StructName)

	// Verify validation errors were detected
	hasValidationErrors := false
	for _, field := range invalidStruct.Fields {
		if !field.IsValid {
			hasValidationErrors = true
			assert.NotEmpty(t, field.ValidationErrors)
		}
	}
	assert.True(t, hasValidationErrors, "Should have validation errors")

	// Run code generation - should skip invalid struct
	err = generateCodeForDirectory(tempDir)
	require.NoError(t, err)

	// Verify no file was generated
	generatedFile := filepath.Join(tempDir, "invalid_encx.go")
	_, err = os.Stat(generatedFile)
	assert.True(t, os.IsNotExist(err), "Should not generate file for invalid struct")
}


func TestComplexStructIntegration(t *testing.T) {
	tempDir := t.TempDir()

	// Create complex struct with all tag combinations
	sourceFile := filepath.Join(tempDir, "complex.go")
	err := os.WriteFile(sourceFile, []byte(`package test

type ComplexUser struct {
	ID             int    `+"`json:\"id\"`"+`

	// Encrypt only
	Phone          string `+"`json:\"phone\" encx:\"encrypt\"`"+`
	PhoneEncrypted []byte `+"`json:\"phone_encrypted\"`"+`

	// Hash basic only
	Username       string `+"`json:\"username\" encx:\"hash_basic\"`"+`
	UsernameHash   string `+"`json:\"username_hash\"`"+`

	// Hash secure only
	SSN            string `+"`json:\"ssn\" encx:\"hash_secure\"`"+`
	SSNHashSecure  string `+"`json:\"ssn_hash_secure\"`"+`

	// Encrypt + Hash basic
	Email          string `+"`json:\"email\" encx:\"encrypt,hash_basic\"`"+`
	EmailEncrypted []byte `+"`json:\"email_encrypted\"`"+`
	EmailHash      string `+"`json:\"email_hash\"`"+`

	// Encrypt + Hash secure
	CreditCard         string `+"`json:\"credit_card\" encx:\"encrypt,hash_secure\"`"+`
	CreditCardEncrypted []byte `+"`json:\"credit_card_encrypted\"`"+`
	CreditCardHashSecure string `+"`json:\"credit_card_hash_secure\"`"+`

	// No encx tags
	Name           string `+"`json:\"name\"`"+`
}
`), 0644)
	require.NoError(t, err)

	err = generateCodeForDirectory(tempDir)
	require.NoError(t, err)

	generatedFile := filepath.Join(tempDir, "complex_encx.go")
	content, err := os.ReadFile(generatedFile)
	require.NoError(t, err)

	contentStr := string(content)

	// Verify all encrypted fields are in the generated struct
	assert.Contains(t, contentStr, "PhoneEncrypted []byte")
	assert.Contains(t, contentStr, "UsernameHash string")
	assert.Contains(t, contentStr, "SSNHashSecure string")
	assert.Contains(t, contentStr, "EmailEncrypted []byte")
	assert.Contains(t, contentStr, "EmailHash string")
	assert.Contains(t, contentStr, "CreditCardEncrypted []byte")
	assert.Contains(t, contentStr, "CreditCardHashSecure string")

	// Verify processing logic for each field type
	assert.Contains(t, contentStr, "crypto.EncryptData(ctx, PhoneBytes, dek)")
	assert.Contains(t, contentStr, "crypto.HashBasic(ctx, UsernameBytes)")
	assert.Contains(t, contentStr, "crypto.HashSecure(ctx, SSNBytes)")
	assert.Contains(t, contentStr, "crypto.EncryptData(ctx, EmailBytes, dek)")
	assert.Contains(t, contentStr, "crypto.HashBasic(ctx, EmailBytes)")
	assert.Contains(t, contentStr, "crypto.EncryptData(ctx, CreditCardBytes, dek)")
	assert.Contains(t, contentStr, "crypto.HashSecure(ctx, CreditCardBytes)")

	// Verify decryption logic (only for encrypted fields)
	assert.Contains(t, contentStr, "crypto.DecryptData(ctx, source.PhoneEncrypted, dek)")
	assert.Contains(t, contentStr, "crypto.DecryptData(ctx, source.EmailEncrypted, dek)")
	assert.Contains(t, contentStr, "crypto.DecryptData(ctx, source.CreditCardEncrypted, dek)")

	// Verify no decryption for hash-only fields
	assert.NotContains(t, contentStr, "crypto.DecryptData(ctx, source.UsernameHash, dek)")
	assert.NotContains(t, contentStr, "crypto.DecryptData(ctx, source.SSNHashSecure, dek)")
}